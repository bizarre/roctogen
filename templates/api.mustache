{{>partial_header}}

use serde::Deserialize;

use crate::adapters::{AdapterError, Json, GitHubRequest, GitHubRequestBuilder, GitHubResponseExt};
use crate::auth::Auth;
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct {{classname}}<'api> {
    auth: &'api Auth
}

pub fn new(auth: &Auth) -> {{classname}} {
    {{classname}} { auth }
}

{{#operations}}{{#operation}}{{#contents}}
#[derive(Debug, thiserror::Error)]
pub enum {{classname}}{{operationIdCamelCase}}Error {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

{{#responses}}{{^vendorExtensions.x-is-default}}
    #[error("{{message}}")]
    Status{{code}}{{#dataType}}({{{.}}}){{/dataType}},
{{/vendorExtensions.x-is-default}}{{/responses}}
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

{{/contents}}{{/operation}}

{{#operation}}{{#contents}}{{#hasQueryParams}}
#[derive(Default, Serialize)]
pub struct {{classname}}{{operationIdCamelCase}}Params {
    {{#queryParams}}
    pub {{paramName}}: {{^required}}Option<{{#isString}}String{{/isString}}{{#isUuid}}String{{/isUuid}}{{^isString}}{{^isUuid}}{{{dataType}}}{{/isUuid}}{{/isString}}>{{/required}}{{#required}}{{#isString}}String{{/isString}}{{#isUuid}}String{{/isUuid}}{{^isString}}{{^isUuid}}{{{dataType}}}{{/isUuid}}{{/isString}}{{/required}}{{#hasMore}}, {{/hasMore}}
    {{/queryParams}}
}

impl {{classname}}{{operationIdCamelCase}}Params {
    pub fn new() -> Self {
        Self::default()
    }
    {{#queryParams}}

    pub fn {{paramName}}(&mut self, {{paramName}}: {{#isString}}impl Into<String>{{/isString}}{{#isUuid}}impl Into<String>{{/isUuid}}{{^isString}}{{^isUuid}}{{{dataType}}}{{/isUuid}}{{/isString}}) -> &mut Self {
        self.{{paramName}} = {{^required}}Some({{/required}}{{paramName}}{{#isString}}.into(){{/isString}}{{#isUuid}}.into(){{/isUuid}}{{^required}}){{/required}};
        self
    }
    {{/queryParams}}
}

{{#vendorExtensions.x-codegen-impl-per-page}}
impl<'enc> From<&'enc PerPage> for {{classname}}{{operationIdCamelCase}}Params {
    fn from(per_page: &'enc PerPage) -> Self {
        let mut this = Self::new();
        this.per_page(per_page.per_page);
        this.page(per_page.page);
        this
    }
}
{{/vendorExtensions.x-codegen-impl-per-page}}
{{/hasQueryParams}}
{{/contents}}{{/operation}}

impl {{classname}}<'_> {
{{#operation}}{{#contents}}
    pub async fn {{operationId}}_async(&self, {{#pathParams}}{{paramName}}: {{#nullable}}Option<{{#isString}}&str{{/isString}}{{#isUuid}}&str{{/isUuid}}{{^isString}}{{^isUuid}}{{{dataType}}}{{/isUuid}}{{/isString}}>{{/nullable}}{{^nullable}}{{#isString}}&str{{/isString}}{{#isUuid}}&str{{/isUuid}}{{^isString}}{{^isUuid}}{{{dataType}}}{{/isUuid}}{{/isString}}{{/nullable}}{{#hasMore}}, {{/hasMore}}{{/pathParams}}{{#hasQueryParams}}{{#hasPathParams}}, {{/hasPathParams}}query_params: {{#vendorExtensions.x-codegen-has-optional-query-params}}Option<{{/vendorExtensions.x-codegen-has-optional-query-params}}impl Into<{{classname}}{{operationIdCamelCase}}Params>{{#vendorExtensions.x-codegen-has-optional-query-params}}>{{/vendorExtensions.x-codegen-has-optional-query-params}}{{#hasBodyParam}}, {{/hasBodyParam}}{{/hasQueryParams}}{{#hasBodyParam}}{{^hasQueryParams}}{{#hasPathParams}}, {{/hasPathParams}}{{/hasQueryParams}}body: {{#bodyParam}}{{{dataType}}}{{/bodyParam}}{{/hasBodyParam}}) -> Result<{{#responses}}{{#vendorExtensions.x-is-default}}{{{dataType}}}{{/vendorExtensions.x-is-default}}{{/responses}}{{#vendorExtensions.x-codegen-response-empty-default}}(){{/vendorExtensions.x-codegen-response-empty-default}}, {{classname}}{{operationIdCamelCase}}Error> {

        let {{#hasQueryParams}}mut {{/hasQueryParams}}request_uri = format!("{}{{path}}", super::GITHUB_BASE_API_URL{{#hasPathParams}}, {{/hasPathParams}}{{#pathParams}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/pathParams}});

        {{#hasQueryParams}}
        {{#vendorExtensions.x-codegen-has-optional-query-params}}
        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: {{classname}}{{operationIdCamelCase}}Params = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }
        {{/vendorExtensions.x-codegen-has-optional-query-params}}
        {{^vendorExtensions.x-codegen-has-optional-query-params}}
        request_uri.push_str("?");
        let qp: {{classname}}{{operationIdCamelCase}}Params = query_params.into();
        request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        {{/vendorExtensions.x-codegen-has-optional-query-params}}
        {{/hasQueryParams}}

        let req = GitHubRequest {
            uri: request_uri,
            body: (),
            method: "{{httpMethod}}"
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
{{#responses}}{{#vendorExtensions}}{{^x-is-default}}
                {{code}} => {{#dataType}}Err({{classname}}{{operationIdCamelCase}}Error::Status{{code}}(github_response.to_json()?)){{/dataType}}{{^dataType}}Err({{classname}}{{operationIdCamelCase}}Error::Status{{code}}){{/dataType}},
{{/x-is-default}}{{/vendorExtensions}}{{/responses}}
                code => Err({{classname}}{{operationIdCamelCase}}Error::Generic { code }),
            }
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub fn {{operationId}}(&self, {{#pathParams}}{{paramName}}: {{#nullable}}Option<{{#isString}}&str{{/isString}}{{#isUuid}}&str{{/isUuid}}{{^isString}}{{^isUuid}}{{{dataType}}}{{/isUuid}}{{/isString}}>{{/nullable}}{{^nullable}}{{#isString}}&str{{/isString}}{{#isUuid}}&str{{/isUuid}}{{^isString}}{{^isUuid}}{{{dataType}}}{{/isUuid}}{{/isString}}{{/nullable}}{{#hasMore}}, {{/hasMore}}{{/pathParams}}{{#hasQueryParams}}{{#hasPathParams}}, {{/hasPathParams}}query_params: {{#vendorExtensions.x-codegen-has-optional-query-params}}Option<{{/vendorExtensions.x-codegen-has-optional-query-params}}impl Into<{{classname}}{{operationIdCamelCase}}Params>{{#vendorExtensions.x-codegen-has-optional-query-params}}>{{/vendorExtensions.x-codegen-has-optional-query-params}}{{#hasBodyParam}}, {{/hasBodyParam}}{{/hasQueryParams}}{{#hasBodyParam}}{{^hasQueryParams}}{{#hasPathParams}}, {{/hasPathParams}}{{/hasQueryParams}}body: {{#bodyParam}}{{{dataType}}}{{/bodyParam}}{{/hasBodyParam}}) -> Result<{{#responses}}{{#vendorExtensions.x-is-default}}{{{dataType}}}{{/vendorExtensions.x-is-default}}{{/responses}}{{#vendorExtensions.x-codegen-response-empty-default}}(){{/vendorExtensions.x-codegen-response-empty-default}}, {{classname}}{{operationIdCamelCase}}Error> {

        let {{#hasQueryParams}}mut {{/hasQueryParams}}request_uri = format!("{}{{path}}", super::GITHUB_BASE_API_URL{{#hasPathParams}}, {{/hasPathParams}}{{#pathParams}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/pathParams}});

        {{#hasQueryParams}}
        {{#vendorExtensions.x-codegen-has-optional-query-params}}
        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: {{classname}}{{operationIdCamelCase}}Params = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }
        {{/vendorExtensions.x-codegen-has-optional-query-params}}
        {{^vendorExtensions.x-codegen-has-optional-query-params}}
        request_uri.push_str("?");
        let qp: {{classname}}{{operationIdCamelCase}}Params = query_params.into();
        request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        {{/vendorExtensions.x-codegen-has-optional-query-params}}
        {{/hasQueryParams}}

        let req = GitHubRequest {
            uri: request_uri,
            body: (),
            method: "{{httpMethod}}"
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
{{#responses}}{{#vendorExtensions}}{{^x-is-default}}
                {{code}} => {{#dataType}}Err({{classname}}{{operationIdCamelCase}}Error::Status{{code}}(github_response.to_json()?)){{/dataType}}{{^dataType}}Err({{classname}}{{operationIdCamelCase}}Error::Status{{code}}){{/dataType}},
{{/x-is-default}}{{/vendorExtensions}}{{/responses}}
                code => Err({{classname}}{{operationIdCamelCase}}Error::Generic { code }),
            }
        }
    }

{{/contents}}{{/operation}}{{/operations}}
}
